
define('text!widgets/ContextMenu/_contextMenu.html',[],function () { return '<div class="ebContextMenu">\n    <div class="ebContextMenu-ExpandBtn" tabindex="1">\n        <i class="ebIcon ebIcon_medium ebIcon_menu"></i>\n    </div>\n    <div class="ebContextMenu-Dropdown"></div>\n</div>';});

/*global define*/
define('widgets/ContextMenu/ContextMenuView',[
    'jscore/core',
    'text!./_contextMenu.html'
], function(core, template) {
    

    var ContextMenuView =  core.View.extend({

        /*jshint validthis:true*/

        // TODO: Should be added to core.View and executed after render()
        afterRender: function () {
            this.outerEl = this.getElement().find('.' + ContextMenuView.OUTER_CLASS);
            this.expandBtn = this.getElement().find('.' + ContextMenuView.EXPANDBTN_CLASS);
            this.dropdown = this.getElement().find('.' + ContextMenuView.DROPDOWN_CLASS);
            this.expandBtnIcon = this.expandBtn.find('.ebIcon');
        },

        getTemplate: function() {
            return template;
        },

        setTitle: function(caption) {
            this.outerEl.setText(caption);
            this.outerEl.setAttribute('title', caption);
        },

        getTitle: function() {
            return this.outerEl.getText();
        },

        getOuterEl: function() {
            return this.outerEl;
        },

        getExpandBtn: function() {
            return this.expandBtn;
        },

        getDropdown: function() {
            return this.dropdown;
        },

        showDropdown: function(visible) {
            this.dropdown.setModifier('visible', '' + visible);
        },

        enableMenu: function(enable) {
            if(enable) {
                this.expandBtnIcon.removeModifier('disabled');
                this.expandBtnIcon.setModifier('interactive');
            } else {
                this.expandBtnIcon.removeModifier('interactive');
                this.expandBtnIcon.setModifier('disabled');
            }
        }

    }, {
        OUTER_CLASS: 'ebContextMenu',
        EXPANDBTN_CLASS: 'ebContextMenu-ExpandBtn',
        DROPDOWN_CLASS: 'ebContextMenu-Dropdown'
    });

    return ContextMenuView;
});

define('text!widgets/ComponentList/_componentList.html',[],function () { return '<div class="ebComponentList"></div>';});

define('text!widgets/ComponentList/_componentListItem.html',[],function () { return '<div class="ebComponentList-item"></div>';});

define('text!widgets/ComponentList/_componentListSeparator.html',[],function () { return '<div class="ebComponentList-separator"></div>';});

/*global define*/
define('widgets/ComponentList/ComponentListView',[
    'jscore/core',
    'text!./_componentList.html',
    'text!./_componentListItem.html',
    'text!./_componentListSeparator.html'
], function (core, template, listItemTemplate, listSeparatorTemplate) {
    

    return core.View.extend({

        getTemplate: function () {
            return template;
        },

        // TODO: Should be added to core.View and executed after render()
        afterRender: function () {},

        addItem: function (itemObj) {
            var $itemEl = core.Element.parse(listItemTemplate);
            $itemEl.setText(itemObj.name);
            $itemEl.setAttribute('title', itemObj.title ? itemObj.title : itemObj.name);

            this.getElement().append($itemEl);
            return $itemEl;
        },

        addSeparator: function () {
            this.getElement().append(core.Element.parse(listSeparatorTemplate));
        }

    });

});
/*global define, Object*/
define('widgets/ComponentList/ComponentList',[
    'widgets/main',
    './ComponentListView'
], function (core, View) {
    

    /**
     * The ComponentList class uses the Ericsson brand assets.<br>
     * The ComponentList can be instantiated using the constructor ComponentList.
     *
     * <strong>Constructor:</strong>
     *   <ul>
     *     <li>ComponentList(Object options)</li>
     *   </ul>
     *
     * <strong>Events:</strong>
     *   <ul>
     *     <li>itemSelected: this event is triggered when value is selected in the ComponentList</li>
     *   </ul>
     *
     * <strong>Options:</strong>
     *   <ul>
     *       <li>items: an array used as a list of available items in the ComponentList</li>
     *   </ul>
     *
     * @private
     * @class ComponentList
     */
    return core.Widget.extend({
        /*jshint validthis:true */

        // constants
        TYPE_SEPARATOR: 'separator',

        View: View,

        /**
         * The init method is automatically called by the constructor when using the "new" operator. If an object with
         * key/value pairs was passed into the constructor then the options variable will have those key/value pairs.
         *
         * @method init
         * @param {Object} options
         * @private
         */
        init: function (options) {
            this.selectedItem = {};
        },

        /**
         * Overrides method from widget.
         * Executes every time, when added back to the screen.
         *
         * @method onViewReady
         * @private
         */
        onViewReady: function () {
            // TODO: not yet in jsCore. Will be removed in the future.
            this.view.afterRender();

            if (this.options.items !== undefined) {
                this.setItems(this.options.items);
            }

            this.getElement().addEventHandler('itemSelected', function () {
                this.trigger('itemSelected');
            }, this);
        },

        /**
         * Gets values from the ComponentList
         *
         * @method getItems
         * @return {Array} items
         */
        getItems: function () {
            return this.items;
        },

        /**
         * Sets values to the ComponentList
         *
         * @method setItems
         * @param {Array} items
         */
        setItems: function (items) {
            this.getElement().children().forEach(function (child) {
                child.remove();
            });

            if (items.length === 0) {
                return;
            }
            this.items = items;

            items.forEach(function (itemObj, index) {
                if (itemObj.type === this.TYPE_SEPARATOR) {
                    this.view.addSeparator();
                } else {
                    var $item = this.view.addItem(itemObj);
                    $item.addEventHandler('click', function () {
                        _onListItemClicked.call(this, index);
                    }, this);
                }
            }, this);
        },

        /**
         * Returns current selected item
         *
         * @method getSelectedValue
         * @return {String}
         */
        getSelectedValue: function () {
            return this.selectedItem;
        }

        /**
         * Add event handle for the ComponentList
         *
         * @method addEventHandler
         * @param {String} action
         * @param {Function} callback
         * @param {Object} context
         */

    });

    /* ++++++++++++++++++++++++++++++++++++++++++ PRIVATE METHODS ++++++++++++++++++++++++++++++++++++++++++ */

    /**
     * An event which is executed when on the list item is clicked
     *
     * @method _onListItemClicked
     * @param {int} index
     * @private
     */
    function _onListItemClicked (index) {
        this.selectedItem = this.items[index];
        if (this.selectedItem !== null) {
            this.trigger('itemSelected');
        }
    }


});

define('widgets/ComponentList', ['widgets/ComponentList/ComponentList'], function (main) { return main; });

/*global define*/
define('widgets/Tooltip/ext/ext.dom',[
], function () {
    

    var dom = {};

    dom.getTagName = function (element) {
        return element._getHTMLElement().tagName.toLowerCase();
    };


    dom.getWindowDimensions = function () {
        return {
            height: window.innerHeight,
            width: window.innerWidth
        };
    };

    dom.getElementDimensions = function (elt) {
        var nativeElt = elt._getHTMLElement();
        return {
            height: nativeElt.clientHeight,
            width: nativeElt.clientWidth
        };
    };

    dom.stopPropagation = function (e) {
        e.originalEvent.stopPropagation();
    };
    dom.getMousePosEvt = function (e) {
        var event = e.originalEvent || window.event;
        var mousePos = {
            left: event.clientX,
            top: event.clientY
        };
        return mousePos;
    };

    return dom;

});
define('text!widgets/Tooltip/_tooltip.html',[],function () { return '<div class="ebTooltip">\n    <div class="ebTooltip-outer">\n        <div class="ebTooltip-contentText"></div>\n    </div>\n</div>\n';});

/*global define*/
define('widgets/Tooltip/TooltipView',[
    'jscore/core',
    './ext/ext.dom',
    'text!./_tooltip.html'
], function(core,domExt, template) {
    

    var TooltipView =  core.View.extend({

        // TODO: Should be added to core.View and executed after render()
        afterRender: function () {
            var element = this.getElement();
            this.outerEl = element.find('.' + TooltipView.OUTER_CLASS);
            this.content = element.find('.' + TooltipView.CONTENT_CLASS);
        },

        getTemplate: function() {
            return template;
        },

		setVisible: function (isVisible) {
            this.getElement().setModifier('visible', '' + isVisible);
		},

		setCorner: function(input) {
            this.outerEl.setModifier('corner', input);
		},

        calcCorner: function(dimensions, offset) {
			//use dimensions and offset to determine which variation of tooltip to show
            var outerElHeight = domExt.getElementDimensions(this.outerEl).height;

			if ( (dimensions.width - offset.left) < domExt.getElementDimensions(this.outerEl).width + 30) {
				if ( (dimensions.height - offset.top) < outerElHeight + 30 ) {
                    updateCorner.call(this, 'bottomRight');
				}
				else {
                    updateCorner.call(this, 'topRight');
				}
			}
			else {
				if ( (dimensions.height - offset.top) < outerElHeight + 30 ) {
                    updateCorner.call(this, 'bottomLeft');
				}
				else {
                    updateCorner.call(this, 'default');
				}
			}
		},

        setContentText: function(caption) {
            this.content.setText(caption);
        },

        getContent: function() {
            return this.content;
        },

		setPosition: function(l, t) {
            this.getElement().setStyle({
                left: l,
                top: t
            });
		}

    }, {
        OUTER_CLASS: 'ebTooltip-outer',
        CONTENT_CLASS: 'ebTooltip-contentText'
    });

    return TooltipView;

    /* ++++++++++++++++++++++++++++++++++++++++++ PRIVATE METHODS ++++++++++++++++++++++++++++++++++++++++++ */

    function updateCorner(cornerName) {
        /*jshint validthis:true*/
        if (this.currentCorner !== cornerName) {
            this.setCorner(cornerName);
            this.currentCorner = cornerName;
        }
    }

});
/*global define*/
define('widgets/Tooltip/Tooltip',[
    'widgets/main',
    './ext/ext.dom',
    './TooltipView'
], function (core, domExt, View) {
    

    /**
     * The Tooltip class uses the Ericsson brand assets.<br>
     * The Tooltip can be instantiated using the constructor Tooltip.
     *
     * The following options are accepted:
     *   <ul>
     *       <li>contentText: the text displayed on the tooltip. Default is "Tooltip"</li>
     *       <li>enabled: boolean indicating whether tooltip should be enabled. Default is true.</li>
     *       <li>modifiers: an array used to define modifiers for the Tooltip. (Asset Library)
     *          <a name="modifierAvailableList"></a>
     *          <br>E.g: modifiers:[{name: 'foo'}, {name: 'bar', value:'barVal'}]
     *          <ul style="padding-left: 15px;">
     *              <li>size: (small | large) size variation</li>
     *          </ul>
     *       </li>
     *       <li>parent: sets the parent of the tooltip.</li>
     *   </ul>
     *
     * @class Tooltip
     */
    return core.Widget.extend({

        /*jshint validthis:true*/

        View: View,

        /**
         * Adds the Widget's element to the new parent element.
         *
         * @method attachTo
         * @param {Element} parent
         * @example
         *    widget.attachTo(this.getElement());
         */

        /**
         * Places the detached Widget back into the defined parent element.
         *
         * @method attach
         * @example
         *  widget.attach();
         */

        /**
         * Removes the Widget from the parent element, but does not destroy the Widget. DOM events will still work when Widget is attached back.
         *
         * @method detach
         * @example
         *  widget.detach();
         */

        /**
         * Overrides method from widget.
         * Executes every time, when added back to the screen.
         *
         * @method onViewReady
         * @private
         */
        onViewReady: function () {
            // TODO: not yet in jsCore. Will be removed in the future.
            this.view.afterRender();

            this.setContentText(this.options.contentText || 'Tooltip');
            this.setModifiers(this.options.modifiers || []);

            if (this.options.enabled !== undefined) {
                this.enabled = this.options.enabled;
            }
            else {
                this.enabled = true;
            }

            setVisible.call(this, false);
            if (this.options.parent) {
                this.parent = this.options.parent;
                this.addHoverHandler(this.parent);
            }
        },

        /**
         * This method sets the contents of the Tooltip
         *
         * @method setContentText
         * @param {String} caption
         */
        setContentText: function (caption) {
            this.view.setContentText(caption);
        },

        /**
         * This method enables the Tooltip
         *
         * @method enable
         */
        enable: function () {
            this.enabled = true;
        },

        /**
         * This method disables the Tooltip
         *
         * @method disable
         */
        disable: function () {
            this.enabled = false;
            setVisible.call(this, false);
        },

        /**
         * Add a single modifier to the widget.<br>
         * <a href="#modifierAvailableList">see available modifiers</a>
         *
         * @method setModifier
         * @param {String} key
         * @param {String|boolean|int} value
         */
        setModifier: function (key, value) {
            this.getElement().setModifier(key, value);
        },

        /**
         * A methods, which allows to define a list of modifiers to the widget.<br>
         * <a href="#modifierAvailableList">see available modifiers</a>
         *
         * @param {Array} modifiers Contains objects {name: {String}[, value: {String}]}
         */
        setModifiers: function (modifiers) {
            modifiers.forEach(function (modifier) {
                this.setModifier(modifier.name, modifier.value);
            }, this);
        },

        /**
         * Remove the modifier 'key' from the widget modifiers.
         *
         * @method removeModifier
         * @param {String} key
         */
        removeModifier: function (key) {
            this.getElement().removeModifier(key);
        },


        /**
         * This method adds the event listeners required to make the tooltip function.
         * It accepts the parent element as input.
         * This method is called automatically if the parent is passed into the constructor.
         *
         * @method addHoverHandler
         * @param {Object} parent
         */
        addHoverHandler: function (parent) {
            if (parent) {
                this.parent = parent;
            }
            this.parent.addEventHandler('mouseover', function (e) {
                if (this.enabled) {
                    domExt.stopPropagation(e);
                    var mousePos = domExt.getMousePosEvt(e);
                    setPosition.call(this, mousePos.left, mousePos.top);
                    calcCorner.call(this, mousePos);
                    setVisible.call(this, true);
                }
            }.bind(this));

            this.parent.addEventHandler('mousemove', function (e) {
                if (this.enabled) {
                    domExt.stopPropagation(e);
                    var mousePos = domExt.getMousePosEvt(e);
                    setPosition.call(this, mousePos.left, mousePos.top);
                    calcCorner.call(this, mousePos);
                }
            }.bind(this));

            this.parent.addEventHandler('mouseout', function (e) {
                if (this.enabled) {
                    domExt.stopPropagation(e);
                    setVisible.call(this, false);
                }
            }.bind(this));
        },

        /**
         * This method removes the event listeners required to make the tooltip function.
         *
         * @method removeHoverHandler
         */
        removeHoverHandler: function () {

        }


        /**
         * Removes the Widget root Element from the DOM.
         *
         * @method destroy
         *
         * @example
         *    tooltip.destroy();
         */

    });

    /* ++++++++++++++++++++++++++++++++++++++++++ PRIVATE METHODS ++++++++++++++++++++++++++++++++++++++++++ */

    function calcCorner(mousePos) {
        this.view.calcCorner(domExt.getWindowDimensions(), mousePos); //pass dimensions and mouse position to calcCorner fn in view
    }


    function setPosition(left, top) {
        this.view.setPosition(left, top);
    }

    function setVisible(isVisible) {
        this.view.setVisible(isVisible);
    }

});
define('widgets/Tooltip', ['widgets/Tooltip/Tooltip'], function (main) { return main; });

/*global define*/
define('widgets/ContextMenu/ContextMenu',[
    'widgets/main',
    './ContextMenuView',
    'widgets/ComponentList',
    'widgets/Tooltip'
], function (core, View, ComponentList, Tooltip) {
    

    /**
     * The ContextMenu class uses the Ericsson brand assets.<br>
     * The ContextMenu can be instantiated using the constructor ContextMenu.
     *
     * The following options are accepted:
     *   <ul>
     *       <li>enabled: boolean indicating whether ContextMenu should be enabled. Default is true.</li>
     *       <li>corner: String that specifies which side of the icon the dropdown is aligned with.</li>
     *          <br>Possible values are default, topRight, bottomLeft and bottomRight.</li>
     *       <li>persistent: boolean indicating whether the ContextMenu should be persistent (ie will remain open if it loses focus). Default is false.</li>
     *       <li>actions: an object used as a list of available actions
     *       <br>e.g. actions: <b>{</b> 'Message': function(){alert('Foo')} <b>}</b> </li>
     *   </ul>
     *
     * @class ContextMenu
     */
    return core.Widget.extend({

        View: View,

        /**
         * Adds the Widget's element to the new parent element.
         *
         * @method attachTo
         * @param {Element} parent
         * @example
         *    widget.attachTo(this.getElement());
         */

        /**
         * Places the detached Widget back into the defined parent element.
         *
         * @method attach
         * @example
         *  widget.attach();
         */

        /**
         * Removes the Widget from the parent element, but does not destroy the Widget. DOM events will still work when Widget is attached back.
         *
         * @method detach
         * @example
         *  widget.detach();
         */

        /**
         * Overrides method from widget.
         * Executes every time, when added back to the screen.
         *
         * @method onViewReady
         * @private
         */
        onViewReady: function () {
            // TODO: not yet in jsCore. Will be removed in the future.
            this.view.afterRender();

            if (this.options.enabled !== undefined && !this.options.enabled) {
                this.disable();
            } else {
                this.enable();
            }

            if (this.options.title) {
                this.title = this.options.title;
                this.setTitle(this.title);
            }

            this.persistent = this.options.persistent || false;
            this.corner = this.options.corner || 'default';
            if ((this.corner === 'default') || (this.corner === 'topRight') || (this.corner === 'bottomLeft') || (this.corner === 'bottomRight')) {
                this.setCorner(this.corner);
            }
            else {
                this.corner = 'default';
            }
            this.setActions(this.options.actions || {});
            showDropdown.call(this, false);
            addExpandHandler.call(this);
            if (!this.persistent) {
                addBlurHandler.call(this);
            }
        },

        /**
         * Sets actions for the contextMenu. If actions array is empty then ContextMenu is disabled. For example syntax consult the actions option in the init method.
         *
         * @method setActions
         * @param {Object} actions
         */
        setActions: function (actions) {
            this.actions = actions;
            var keys = Object.keys(actions);
            if (keys.length > 0) {
                if (this.componentList === undefined) {
                    this.componentList = new ComponentList({
                        items: keys
                    });
                    this.componentList.attachTo(this.getDropdown());
                    this.componentList.addEventHandler('itemSelected', this._onComponentListClick, this);
                } else {
                    this.componentList.setItems(keys);
                }
            } else {
                this.disable();
            }
        },

        /**
         * This method enables the ContextMenu
         *
         * @method enable
         */
        enable: function () {
            enableMenu.call(this, true);
        },

        /**
         * This method disables the ContextMenu
         *
         * @method disable
         */
        disable: function () {
            enableMenu.call(this, false);
        },

        /**
         * This method sets the position of the dropdown for the ContextMenu. Four values are possible: "default", "topRight", "bottomLeft" and "bottomRight".
         * If "default" is specified, the dropdown will be aligned with the left side of the icon.
         *
         * @method setCorner
         * @param {String} corner
         */
        setCorner: function(corner) {
            this.getDropdown().setModifier('corner', corner);
        },

        /**
         * This method sets the tooltip that will be displayed when the user hovers over the menu icon.<br>
         * If empty text is put as parameter, than exists tooltip will be destroyed.
         *
         * @method setTitle
         * @param {String} title
         */
        setTitle: function(title) {
            this.title = title;
            if (!this.tooltip) {
                this.tooltip = new Tooltip({
                    parent: this.view.getExpandBtn(),
                    contentText: this.title,
                    enabled: true
                });
                this.tooltip.attachTo(this.getElement());
            } else {
                this.tooltip.setContentText(this.title);
            }

            if (title === '' && this.tooltip) {
                this.tooltip.destroy();
                delete this.tooltip;
            }
        },

        /**
         * This method returns the string that is displayed on the menu icon tooltip.
         *
         * @method getTitle
         */
        getTitle: function () {
            if (this.tooltip) {
                return this.title;
            }
            return '';
        },

        /**
         * This method returns the dropdown element. Used for testing only.
         * @method getDropdown
         * @private
         */
        getDropdown: function () {
            return this.view.getDropdown();
        },

        /**
         * This method returns the expand button element. Used for testing only.
         * @method getExpandBtn
         * @private
         */
        getExpandBtn: function () {
            return this.view.getExpandBtn();
        },

        /**
         * An event which is executed when clicked on the dropdown
         *
         * @method _onDropdownClick
         * @private
         */
        _onDropdownClick: function () {
            showDropdown.call(this, false);
            this.view.getButton().trigger('focus');
        },

        /**
         * An event which is executed when an action is selected from componentList
         *
         * @method _onComponentListClick
         * @private
         */
        _onComponentListClick: function () {
            showDropdown.call(this, false);
            var selectedActionName = this.componentList.getSelectedValue();
            this.actions[selectedActionName]();
        }


        /**
         * Removes the Widget root Element from the DOM.
         *
         * @method destroy
         *
         * @example
         *    contextMenu.destroy();
         */

    });

    /* ++++++++++++++++++++++++++++++++++++++++++ PRIVATE METHODS ++++++++++++++++++++++++++++++++++++++++++ */

    function addBlurHandler() {
        /*jshint validthis:true*/
        this.view.getExpandBtn().addEventHandler('blur', function () {
            if (!this.dropdownHasMouse) {
                showDropdown.call(this, false);
            } else {
                this.getElement().trigger('focus');
            }
        }, this);
    }

    function addExpandHandler() {
        /*jshint validthis:true*/
        this.getExpandBtn().addEventHandler('click',  function () {
            if (this.enabled) {
                showDropdown.call(this, !this.dropdownShown);
            }

            this.view.getDropdown().addEventHandler('mouseenter', function () {
                this.dropdownHasMouse = true;
            }, this);

            this.view.getDropdown().addEventHandler('mouseleave', function () {
                this.dropdownHasMouse = false;
            }, this);
        }.bind(this));
    }

    function showDropdown(visible) {
        /*jshint validthis:true*/
        this.view.showDropdown(visible);
        this.dropdownShown = visible;
    }

    function enableMenu (enable) {
        /*jshint validthis:true*/
        this.enabled = enable;
        this.view.enableMenu(enable);
    }
});
define('widgets/ContextMenu', ['widgets/ContextMenu/ContextMenu'], function (main) { return main; });
