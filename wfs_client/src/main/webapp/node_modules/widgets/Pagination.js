
define('text!widgets/Pagination/Pagination.html',[],function () { return '<ul class="ebPagination">\n\t<li class="ebPagination-previous">\n\t\t<a class="ebPagination-previous-anchor" href="#"></a>\n\t</li>\n\t<li class="ebPagination-pagesContainer">\n\t\t<ul class="ebPagination ebPagination-pages">\n\t\t</ul>\n\t</li>\n\t<li class="ebPagination-next">\n\t\t<a class="ebPagination-next-anchor" href="#"></a>\n\t</li>\n</ul>\n';});

define('widgets/Pagination/PaginationView',[
	"jscore/core",
	"text!./Pagination.html"
], function(core, template) {

	return core.View.extend({

		getTemplate: function() {
			return template;
		},
		
		getPreviousLi: function() {
			return this.getElement().find(".ebPagination-previous");
		},
		
		getPrevious: function() {
			return this.getElement().find(".ebPagination-previous-anchor");
		},
		getWrapper: function() {
			return this.getElement();
		},
		
		getPages: function() {
			return this.getElement().find(".ebPagination-pages");
		},
		
		getNext: function() {
			return this.getElement().find(".ebPagination-next-anchor");
		}
	});

});
/*global define, parseInt, Math, setTimeout*/
define('widgets/Pagination/Pagination',[
    "widgets/main",
    "./PaginationView"
], function (core, View) {
    


    function insertBeforeChild(page, child) {
        child._getHTMLElement().parentNode.insertBefore(page._getHTMLElement(), child._getHTMLElement());
    }

    function insertAfterChild(page, child) {
        child._getHTMLElement().parentNode.insertBefore(page._getHTMLElement(), child._getHTMLElement().nextSibling);
    }

    function insertPage(number, whereFn, child) {
        /*jshint validthis:true */
        var page = this.createPage(number, this.selectedPage === number);
        if (whereFn) {
            whereFn.call(this, page, child);
        } else {
            this.view.getPages().append(page);
        }
        this._freeSpace -= this.getPageWidth(number);
        this._currPage = this.selectedPage == number? page : this._currPage;
        return page;
    }

    /**
     * This widget uses the pagination brand asset to create a widget which will produce clickable page numbers which developers can react to.<br>
     * The InfoPopup can be instantiated using the constructor InfoPopup.
     *
     * <strong>Events:</strong>
     *   <ul>
     *       <li>pagechange: Triggers when the highlighed page has changed. Passes the page number as a parameter.</li>
     *   </ul>
     *
     * The following options are accepted:
     *   <ul>
     *       <li>pages: number of page links to create</li>
     *       <li>selectedPage: the number of the page to be highlighted as selected/li>
     *       <li>onPageChange: Function callback, triggers when a page has been clicked.</li>
     *       <li>url: If string, the href for each page link will be "#&lt;url&gt;/&lt;pageNumber&gt;". If function, a string is expected to be returned (the page number is passed into the function). If no url is specified, then the location will not change.</li>
     *       <li>maxWidth: The maximum width the pagination widget will take. Default is 500px.</li>
     *   </ul>
     *
     * @class Pagination
     */
    var Pagination = core.Widget.extend({

        View: View,

        /**
         * Adds the Widget's element to the new parent element.
         *
         * @method attachTo
         * @param {Element} parent
         * @example
         *    widget.attachTo(this.getElement());
         */

        /**
         * Places the detached Widget back into the defined parent element.
         *
         * @method attach
         * @example
         *  widget.attach();
         */

        /**
         * Removes the Widget from the parent element, but does not destroy the Widget. DOM events will still work when Widget is attached back.
         *
         * @method detach
         * @example
         *  widget.detach();
         */

        /**
         * Initialises events and creates the links
         *
         * @method onViewReady
         * @private
         */
        onViewReady: function () {
            this.totalPages = this.options.pages || 0;
            this.selectedPage = this.options.selectedPage || 1;
            this.url = this.options.url;

            this.view.getPrevious().addEventHandler("click", function (e) {
                this.previousPageClickHandler(e);
            }.bind(this));

            this.view.getNext().addEventHandler("click", function (e) {
                this.nextPageClickHandler(e);
            }.bind(this));

            setTimeout(function () {
                this.setPage(this.selectedPage);
            }.bind(this), 1);

            window.addEventListener("resize", function () {
                this.redraw();
            }.bind(this), false);

            this.view.getElement().setStyle("max-width", this.options.maxWidth || "500px");

        },

        /**
         * Click handler for the previous page button
         *
         * @method previousPageClickHandler
         * @private
         * @param {Event} e
         */
        previousPageClickHandler: function (e) {
            this.previousPage();
            this.view.getPrevious().setAttribute("href", "#" + this.getUrl(this.selectedPage));
            if (!this.url) {
                e.preventDefault();
            }
        },

        /**
         * Click handler for the next page button
         *
         * @method nextPageClickHandler
         * @private
         * @param {Event} e
         */
        nextPageClickHandler: function (e) {
            this.nextPage();
            this.view.getNext().setAttribute("href", "#" + this.getUrl(this.selectedPage));
            if (!this.url) {
                e.preventDefault();
            }
        },

        /**
         * Click handler for page buttons
         *
         * @method pageClickHandler
         * @private
         * @param {int} pageNumber
         * @param {Event} e
         */
        pageClickHandler: function (pageNumber, e) {
            this.setPage(pageNumber);
            if (!this.url) {
                e.preventDefault();
            }
        },

        /**
        *   Calculates the amount of free space remaining for pages (width - previousBtn - nextBtn)
        *
        *   @method calculateFreeSpace
        *   @private
        *   @return {Integer} freeSpace
        */
        calculateFreeSpace: function() {
            var parentWidth = this.view.getWrapper().getProperty("offsetWidth") - this._pageMargin; // 2px margin
            return Math.floor((parentWidth - this._minWidth * 2));
        },

        /**
        *   Gets the width of the page by calculating the number of characters, then adding padding + margin. OffsetWidth is far too slow to use.
        *
        *   @method getPageWidth
        *   @private
        *   @param {Integer} pageNumber
        *   @return {Integer} pageWidth
        */
        getPageWidth: function(pageNumber) {
            return Math.max((pageNumber === 0? 1 : parseInt(Math.log(pageNumber) / Math.LN10 + 1, 10)) * this._numberWidth + this._pageMargin + this._pagePadding, this._minWidth);

        },

        /**
        *   Calculates the minimum pixel width including margin of a page element
        *
        *   @method calculateMinPageWidth
        *   @private
        *   @return {Integer} minWidth
        */
        calculateMinPageWidth: function() {
            var computedStyle = window.getComputedStyle(this.view.getPreviousLi()._getHTMLElement(), null);
            var marginLeft = parseInt(computedStyle.getPropertyValue("margin-left"), 10);
            var marginRight = parseInt(computedStyle.getPropertyValue("margin-right"), 10);
            this._pagePadding = 8;
            this._pageMargin = marginLeft + marginRight;
            this._minWidth = this.view.getPrevious().getProperty("offsetWidth") + this._pageMargin;
        },

        /**
        *   Calculates the pixel size of the number. This is used by getPageWidth to figure out how wide it the page is.
        *
        *   @method calculateNumberWidth
        *   @private
        *   @param {Integer} number
        */
        calculateNumberWidth: function(number) {
            var li = core.Element.parse("<li class=\"ebPagination-entry\"><a style=\"width:auto\" class=\"ebPagination-entry-anchor ebPagination-entry-anchor_current\" href=\"#\">"+number+"</a></li>");
            this.view.getPages().append(li);
            this._numberWidth = li.children()[0].getProperty("offsetWidth") - 8;
            li.remove();
        },

        /**
         * Clears and renders the widget
         *
         * @method redraw
         */
        redraw: function() {

            this.removePages();
            this.calculateNumberWidth(1);
            this.calculateMinPageWidth();

            this._freeSpace = this.calculateFreeSpace();
            var leftIndex = this.selectedPage - 1;
            var rightIndex = this.selectedPage + 1;
            var currPage;

            var firstPage = insertPage.call(this, 1);

            if (this.selectedPage != 1 && this.selectedPage != this.totalPages) {
                insertPage.call(this, this.selectedPage);
            }

            var lastPage;
            if (this.totalPages != 1) {
                lastPage = insertPage.call(this, this.totalPages);
            }



            var leftElem = this._currPage;
            var rightElem = this._currPage;
            while (this._freeSpace > 0) {
                if ((rightIndex < this.totalPages) && (this._freeSpace - this.getPageWidth(rightIndex) >= 0)) {
                    rightElem = insertPage.call(this, rightIndex, insertAfterChild, rightElem);
                    rightIndex++;
                }

                if ((leftIndex > 1) && (this._freeSpace - this.getPageWidth(leftIndex) >= 0)) {
                    leftElem = insertPage.call(this, leftIndex, insertBeforeChild, leftElem);
                    leftIndex--;
                }


                if ((leftIndex <= 1 && rightIndex >= this.totalPages) || (this._freeSpace - this.getPageWidth(leftIndex) < 0 && this._freeSpace - this.getPageWidth(rightIndex) < 0) ) {
                   if (leftIndex > 1) {
                        this.view.getPages().children()[1].remove();
                        insertAfterChild(this.createDots(), firstPage);
                    }
                    if (rightIndex < this.totalPages) {
                        this.view.getPages().children()[this.view.getPages().children().length - 2].remove();
                        insertBeforeChild(this.createDots(), lastPage);
                    }
                    break;
                }

            }

            this.view.getPrevious().removeModifier("disabled");
            this.view.getNext().removeModifier("disabled");

            if (this.selectedPage == 1) {
                this.view.getPrevious().setModifier("disabled");
            }

            if (this.selectedPage == this.totalPages) {
                this.view.getNext().setModifier("disabled");
            }

        },

        /**
         * Creates a "..." element
         *
         * @method createDots
         * @private
         */
        createDots: function() {
            var dotsElem = core.Element.parse("<li class='ebPagination-entry'><a class='ebPagination-entry-anchor ebPagination-entry-anchor_dots' href='#'>...</a></li>");

            dotsElem.children()[0].addEventHandler("click", function (e) {
                e.preventDefault();
            }.bind(this));

            return dotsElem;
        },

        /**
         * Selects the previous page and triggers callback
         *
         * @method previousPage
         */
        previousPage: function () {
            if (this.selectedPage > 1) {
                this.selectedPage--;
                this.setPage(this.selectedPage);
            }
        },

        /**
         * Selects the next page and triggers callback
         *
         * @method nextPage
         */
        nextPage: function () {
            if (this.selectedPage < this.totalPages) {
                this.selectedPage++;
                this.setPage(this.selectedPage);
            }
        },

        /**
         * Creates a page element with the specified page number to the list of pages. If selected is true, it will be highlighted.
         *
         * @method createPage
         * @private
         * @param {int} pageNumber
         * @param {Boolean} selected
         */
        createPage: function(pageNumber, selected) {
            var pageElem = core.Element.parse("<li class='ebPagination-entry'><a class='ebPagination-entry-anchor' href='#" + this.getUrl(pageNumber) + "'>" + pageNumber + "</a></li>");

            pageElem.children()[0].addEventHandler("click", function (e) {
                this.pageClickHandler(pageNumber, e);
            }.bind(this));

            if (selected) {
                pageElem.children()[0].setModifier("current");
            }

            return pageElem;
        },

        /**
         * If the url option is a string, it will return <url>/<pageNumber>. If the url is a function, it will pass the page number into that function and expect a string to be returned.
         *
         * @method getUrl
         * @private
         * @param {int} pageNumber
         * @return {String} url
         */
        getUrl: function (pageNumber) {
            if (this.url && typeof this.url === "string") {
                return this.url + "/" + pageNumber;
            } else if (this.url && typeof this.url === "function") {
                return this.url(pageNumber);
            } else {
                return "";
            }
        },

        /**
         * Triggers the callback passing the pageNumber as a parameter
         *
         * @method triggerCallback
         * @private
         * @param {int} pageNumber
         */
        triggerCallback: function (pageNumber) {
            if (this.options.onPageChange) {
                this.options.onPageChange(pageNumber);
            }
            this.trigger("pagechange", pageNumber);
        },

        /**
         * Empties out the list of pages
         *
         * @method removePages
         * @private
         */
        removePages: function () {
            var pages = this.view.getPages().children();
            var len = pages.length;
            while (len--) {
                pages[len].remove();
            }
        },

        /**
         * Selects the page and forces a draw.
         *
         * @method setPage
         * @param {int} pageNumber
         */
        setPage: function (pageNumber) {
            if (pageNumber > 0 && pageNumber <= this.totalPages) {
                this.selectedPage = pageNumber;
                this.redraw();
                this.triggerCallback(pageNumber);
            }
        }


        /**
         * Bind an event handling function to an event.
         *
         * @method addEventHandler
         * @param {String} eventName
         * @param {Function} fn
         * @return {String} id
         * @example
         * pagination.addEventHandler("pagechange", function(pageNumber) {
		 *     console.log("Current Page Number: " + pageNumber);
		 * });
         */

        /**
         * Unbind an event handling function from an event.
         *
         * @method removeEventHandler
         * @param {String} eventName
         * @param {String} id

         * @example
         *    pagination.removeEventHandler("pagechange", eventId);
         */

        /**
         * Removes the Widget root Element from the DOM.
         *
         * @method destroy
         *
         * @example
         *    pagination.destroy();
         */

    });

    return Pagination;
});
define('widgets/Pagination', ['widgets/Pagination/Pagination'], function (main) { return main; });
