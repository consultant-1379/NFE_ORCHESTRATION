
define('text!widgets/Table/Table.html',[],function () { return '<div class="elwidgets-Table eb_scrollbar">\n    <div class="elwidgets-Table-responsiveWrapper">\n        <table class="ebTable elwidgets-Table-body">\n            <colgroup class="ebTable-columns"></colgroup>\n            <thead></thead>\n            <tbody></tbody>\n        </table>\n    </div>\n</div>';});

define('styles!widgets/Table/Table.less',[],function () { return '.elwidgets-Table {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  overflow-y: hidden;\n  overflow-x: auto;\n  /* TODO: This is causing overflowing cells to display incorrectly */\n\n  -webkit-overflow-scrolling: touch;\n}\n.elwidgets-Table-responsiveWrapper,\n.elwidgets-Table-body {\n  width: 100%;\n}\n';});

define('widgets/Table/TableView',[
	"jscore/core",
	"text!./Table.html",
	"styles!./Table.less"
], function(core, template, style) {

	return core.View.extend({

		getTemplate: function() {
			return template;
		},

		getStyle: function() {
			return style;
		},

		getBody: function() {
			return this.getElement().find(".ebTable");
		},
        getTableHeader:function(){
            return this.getBody().find('thead');
        },
        getTableBody:function(){
            return this.getBody().find('tbody');
        },
		getResponsiveWrapper: function() {
			return this.getElement().find(".elwidgets-Table-responsiveWrapper");
		},
		getColumns: function() {
			return this.getElement().find(".ebTable-columns");
		}
	});

});
define('text!widgets/table/Column/Column.html',[],function () { return '<col class="elwidgets-Table-Column"></col>';});

define('styles!widgets/table/Column/Column.less',[],function () { return '.elwidgets-Table-Column {\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  width: auto;\n}\n';});

define('widgets/table/Column/ColumnView',[
	"jscore/core",
	"text!./Column.html",
	"styles!./Column.less"
], function(core, template, styles) {
	
	return core.View.extend({

		getTemplate: function() {
			return template;
		},

		getStyle: function() {
			return styles;
		}
	});

});
/**
*	Column class. Contains functions that provide information about the column.
*
*	@class table.Column
*/
define('widgets/table/Column/Column',[
	"jscore/core",
	"./ColumnView"
], function(core, View) {

	var Column = core.Widget.extend({

		View: View,

		onViewReady: function() {
			if (this.options.definition.width) {
				this.view.getElement().setStyle("width", this.options.definition.width);
			}
		},

		/**
		*	Returns the title of the column
		*
		*	@method getTitle
		*	@return {String} title
		*/
		getTitle: function() {
			return this.options.definition.title || "";
		},

		/**
		*	Returns the index of the column
		*
		*	@method getIndex
		*	@return {Integer} index
		*/
		getIndex: function() {
			return this.options.index;
		},

		/**
		*	Returns the model attribute of the column
		*
		*	@method getAttribute
		*	@return {String} attribute
		*/
		getAttribute: function() {
			return this.options.definition.attribute;
		},

		/**
		*	Returns the original definition the developer specified for the column
		*
		*	@method getDefinition
		*	@return {Object} definition
		*/
		getDefinition: function() {
			return this.options.definition;
		}

	});


	return Column;

});
define('widgets/table/Column', ['widgets/table/Column/Column'], function (main) { return main; });

define('text!widgets/table/Sortable/Sortable.html',[],function () { return '<div class="elwidgets-Table-Sortable">\n\t<i class="elwidgets-Table-Sortable-arrow ebIcon ebIcon_small ebIcon_upArrow_10px"></i>\n\t<i class="elwidgets-Table-Sortable-arrow ebIcon ebIcon_small ebIcon_downArrow_10px"></i>\n</div>';});

define('styles!widgets/table/Sortable/Sortable.less',[],function () { return '.elwidgets-Table-Sortable {\n  margin-left: 8px;\n  vertical-align: middle;\n  display: inline-block;\n  margin-top: -1px;\n}\n.elwidgets-Table-Sortable-arrow {\n  display: block;\n  opacity: 0.2;\n}\n.elwidgets-Table-Sortable-arrow_active {\n  opacity: 1;\n}\n';});

define('widgets/table/Sortable/SortableView',[
	"jscore/core",
	"text!./Sortable.html",
	"styles!./Sortable.less"
], function(core, template, styles) {
	
	return core.View.extend({

		getTemplate: function() {
			return template;
		},

		getStyle: function() {
			return styles;
		},

		getUpArrow: function() {
			return this.getElement().find(".ebIcon_upArrow_10px");
		},

		getDownArrow: function() {
			return this.getElement().find(".ebIcon_downArrow_10px");
		},

		setBothArrowsInactive: function() {
			this.getUpArrow().removeModifier("active");
			this.getDownArrow().removeModifier("active");
		},

		setUpArrowActive: function() {
			this.getUpArrow().setModifier("active");
			this.getDownArrow().removeModifier("active");
		},

		setDownArrowActive: function() {
			this.getUpArrow().removeModifier("active");
			this.getDownArrow().setModifier("active");
		}

	});

});
define('widgets/table/Sortable/Sortable',[
    "jscore/core",
    "./SortableView"
], function (core, View) {

    var Sortable = core.Widget.extend({

        View: View,

        init: function () {
            this._sortingMode = "";
        },

        click:function(){
            this.trigger('reset');
            this.sortHandler();
        },

        reset: function () {
            this.view.setBothArrowsInactive();
            this._sortingMode = "";
        },

        sortHandler: function () {
            if (this._sortingMode === "" || this._sortingMode === "asc") {
                this._sortingMode = "desc";
                this.view.setDownArrowActive();
            } else {
                this._sortingMode = "asc";
                this.view.setUpArrowActive();
            }
            this.trigger('sort', this._sortingMode);


        }


    });

    return Sortable;

});
define('widgets/table/Sortable', ['widgets/table/Sortable/Sortable'], function (main) { return main; });

/**
 *    Table object which takes an array of objects and displays them with rows and cells.
 *
 *    <strong>Constructor:</strong>
 *    <ul>
 *        <li>Table(Object options)</li>
 *        <li>Table(Object options, Array&lt;Object&gt; data)</li>
 *        <li>Table(Object options, Collection data)</li>
 *    </ul>
 *
 *    <strong>Events:</strong>
 *    <ul>
 *        <li>sort: attribute and sort order are passed as arguments</li>
 *       <li>rowclick: row and model passed as arguments, triggers when a row is clicked</li>
 *       <li>rowselect: row, model, and isSelected passed as arguments, triggers when a selectableRows is enabled and a row is clicked</li>
 *    </ul>
 *
 *    <strong>Options:</strong>
 *    <ul>
 *        <li>modifiers: Array of modifiers that this table should use</li>
 *       <li>rowType: Reference to extended Row to use</li>
 *       <li>headerRowType: Reference to extended to use for the header</li>
 *       <li>cellType: Reference to extended Cell to use for all cells</li>
 *       <li>headerCellType: Reference to extended Cell to use for all header cells</li>
 *       <li>noHeader: if true, the table will not have a header</li>
 *        <li>width: String with a CSS fixed width</li>
 *        <li>minWidth: String with a CSS width</li>
 *        <li>maxWidth: String with a CSS width</li>
 *       <li>tooltips: if true, native browser tooltips are displayed when hovering over a cell</li>
 *       <li>selectableRows: If true, click to select row. If CTRL is held, multiple rows can be selected. If SHIFT is held, a range of rows is selected.</li>
 *        <li>columns: Array of objects which define the columns. Can have the following properties:
 *            <ul>
 *                <li>title: Title for the column.</li>
 *                <li>attribute: The model attribute that the column should look for.</li>
 *                <li>sortable: if true, columns headers can be clicked to trigger a sort event</li>
 *                <li>initialSortIcon: "desc" or "asc", it won't sort the data, but just change the icon</li>
 *                <li>width: String with a CSS fixed width</li>
 *               <li>cellType: Reference to extended Cell to use</li>
 *               <li>headerCellType: Reference to extended Cell to use for the header</li>
 *            </ul>
 *        </li>
 *    </ul>
 *     <strong>Custom Cells are Available:</strong>
 *     <ul>
 *         <li>EditableCell: "widgets/table/EditableCell" </li>
 *         <li>CheckboxCell: "widgets/table/CheckboxCell"</li>
 *         <li>CheckboxHeaderCell: "widgets/table/CheckboxHeaderCell"</li>
 *     </ul>
 *
 *    @class Table
 */
define('widgets/Table/Table',[
    "jscore/core",
    "jscore/ext/mvp",
    "./TableView",
    "widgets/table/Column",
    "widgets/table/Row",
    "widgets/table/HeaderCell",
    "widgets/table/Cell",
    "widgets/table/HeaderRow",
    "widgets/table/Sortable"
], function (core, mvp, View, Column, Row, HeaderCell, Cell, HeaderRow, Sortable) {


    var Table = core.Widget.extend({

        View: View,

        rowType: Row,
        headerRowType: HeaderRow,
        cellType: Cell,
        headerCellType: HeaderCell,

        /**
         *    Called once the Table has been fully initialized
         *
         *    @method onTableReady
         */
        onTableReady: function() {

        },

        /**
         *    Initializes members which are used in this widget
         *
         *    @method init
         *    @private
         */
        init: function (options, data) {
            this.prepareOptions();
            this._eventBus = new core.EventBus();
            this.rowType = this.options.rowType;
            this.headerRowType = this.options.headerRowType;
            this.cellType = this.options.cellType;
            this.headerCellType = this.options.headerCellType;
            this._rows = [];
            this._modelRowBindings = {};
            this._events = {};
            this._columns = this.initializeColumns(this.options.columns);
            this._headerRow = this.initializeHeaderRow(this._columns);
            this._data = data instanceof mvp.Collection ? data : new mvp.Collection(data);
            this._previousSelectedRow = undefined;
            this._selectedRows = [];
            this.setupEvents();
        },

        /**
         *    Creates a new options object, first using properties of the table, then merges in options from constructor
         *
         *    @method prepareOptions
         *    @private
         */
        prepareOptions: function() {
            var output = {};
            for (var prop in this) {
                output[prop] = this[prop];
            }

            for (var opprop in this.options) {
                output[opprop] = this.options[opprop];
            }

            this.options = output;
        },

        /**
         *    Creates default events that components can publish to
         *
         *    @method setupEvents
         *    @private
         */
        setupEvents: function () {
            this.getEventBus().subscribe("rowdestroy", function (row) {
                this._rows.splice(this._rows.indexOf(row), 1);
            }, this);
        },

        /**
         *    Initializes columns, the headerRow, and the data
         *
         *    @method onViewReady
         *    @private
         */
        onViewReady: function () {
            this._columns.forEach(function (column) {
                column.attachTo(this.view.getColumns());
            }.bind(this));

            if (!this.options.noHeader) {
               this._headerRow.attachTo(this.view.getTableHeader());
           }

            this.setData(this._data);

            if (this.options.modifiers) {
                for (var i = 0; i < this.options.modifiers.length; i++) {
                    this.view.getBody().setModifier(this.options.modifiers[i]);
                }
            }

            if (this.options.minWidth) {
                this.view.getResponsiveWrapper().setStyle("min-width", this.options.minWidth);
            }

            if (this.options.maxWidth) {
                this.view.getResponsiveWrapper().setStyle("max-width", this.options.maxWidth);
            }

            if (this.options.width) {
                this.view.getResponsiveWrapper().setStyle("width", this.options.width);
            }

            this.onTableReady();

        },

        /**
         *    Adds the model to the collection and creates a row for it
         *
         *    @method addData
         *    @param {Object | Model} data
         */
        addData: function (model) {
            this._data.addModel(model);
        },

        /**
         *    Creates the row for the model
         *
         *    @method addRow
         *    @private
         *    @param {Model} model
         */
        addRow: function (model) {
            var row = new this.rowType({
                data: model,
                eventBus: this._eventBus
            });

            this._columns.forEach(function (column) {
                var attribute = column.getAttribute();

                var cellType = (column.getDefinition().cellType || this.cellType);
                var cell = new cellType({
                    row: row,
                    column: column,
                    eventBus: this._eventBus,
                    model: model,
                    attribute: attribute
                });


                if (attribute) {
                    // Binding cells to the model attributes
                    if (row.tableCellBindEvents === undefined) {
                        row.tableCellBindEvents = {};
                    }

                    // FIXME
                    // Prevent memory leak or handlers being left over
                     if (row.tableCellBindEvents[attribute]) {
                         model.removeEventHandler("change:" + attribute, row.tableCellBindEvents[attribute]);
                     }

                    row.tableCellBindEvents[attribute] = model.addEventHandler("change:" + attribute, function (model) {
                        cell.setValue(model.getAttribute(attribute));
                    });

                    if (this.options.tooltips) {
                        cell.setTooltip(model.getAttribute(column.getAttribute()));
                    }
                }

                row.attachCell(cell);
            }.bind(this));

            // Attach rowclick event
            row.view.getBody().addEventHandler("click", function () {
                this.trigger("rowclick", row, model);
            }.bind(this));

            // Attach selectable events
            if (this.options.selectableRows) {
                this.applySelectableHandlers(row);
            }

            this._modelRowBindings[model.cid] = row;
            row.attachTo(this.view.getTableBody());
            //TODO: Remove this
            this._rows.push(row);
        },
        /**
         *   Gets the current index of the row
         *
         *   @method getRowIndex
         *   @return {Integer}
         */
        getRowIndex: function (row) {
            return this.getRows().indexOf(row);
        },
        /**
         *  Applies a click handler to the row to allow it to be clicked to highlight.
         *  If "selectableRows" is equal to Table.CTRL, user must hold CTRL while clicking a row to highlight it.
         *  A user can hold shift to highlight multiple rows.
         *  A "rowhighlight" event is thrown for each row changed.
         *
         *  @method applySelectableHandlers
         *  @private
         *  @param {Row} row
         */
        applySelectableHandlers: function (row) {
            // Prevent default shift-click event that browsers might do
            row.view.getBody().addEventHandler("mousedown", function (e) {
                if (e.originalEvent.shiftKey) {
                    e.preventDefault();
                }
            });
             //TODO: Need to move in to custom row
            row.view.getBody().addEventHandler("click", function (e) {

                if (e.originalEvent.shiftKey && this._previousSelectedRow && this._previousSelectedRow !== row) {
                    var prevIndex = this.getRowIndex(this._previousSelectedRow);
                    var nextIndex = this.getRowIndex(row);
                    var start = (prevIndex < nextIndex) ? prevIndex : nextIndex;
                    var end = (prevIndex > nextIndex) ? prevIndex : nextIndex;
                    for (var i = 0; i < this.getRows().length; i++) {
                        this.selectRow(this.getRows()[i], i >= start && i <= end);
                    }
                } else {

                    if (row.isHighlighted() || e.originalEvent.ctrlKey) {
                        this.selectRow(row, !row.isHighlighted());
                    } else {


                        for (var j = 0; j < this._selectedRows.length; j++) {
                            if (this._selectedRows[j] !== row) {
                                this.selectRow(this._selectedRows[j], false, false);
                            }
                        }
                        this._selectedRows = [];
                        this.selectRow(row, !row.isHighlighted());


                    }
                    this._previousSelectedRow = row.isHighlighted() ? row : undefined;
                }

            }, this);
        },

        selectRow: function (row, highlight, splice) {
            splice = !!(splice);

            row.highlight(highlight);
            this.trigger("rowselect", row, row.getData(), row.isHighlighted());

            if (row.isHighlighted() && this._selectedRows.indexOf(row) == -1) {
                this._selectedRows.push(row);
            } else if (!row.isHighlighted() && this._selectedRows.indexOf(row) != -1 && splice) {
                this._selectedRows.splice(this._selectedRows.indexOf(row), 1);
            }
        },


        /**
         *    Clears the table and adds rows for the passed collection
         *
         *    @method setData
         *    @param {Array<Object> | Collection} data
         */
        setData: function (collection) {
            this._selectedRows = [];

            if (collection) {
                this.clear();
                collection = collection instanceof mvp.Collection ? collection : new mvp.Collection(collection);

                this._data = collection;

                collection.each(function (model) {
                    this.addRow(model);
                }.bind(this));

                this._events.add = this._data.addEventHandler("add", function (model) {
                    this.addRow(model);
                }, this);

                this._events.remove = this._data.addEventHandler("remove", function (model) {
                    this.removeRow(model);
                }, this);

                this._events.reset = this._data.addEventHandler("reset", function () {
                    this.setData(this._data);
                }.bind(this));

                this._events.sort = this._data.addEventHandler("sort", function () {
                    this.sortRender();
                }, this);
            }
        },

        /**
         *    Removes the model from the collection and destroys the row for it
         *
         *    @method removeData
         *    @param {Model} data
         */
        removeData: function (model) {
            this._data.removeModel(model);
        },

        /**
         *    Removes the row for the model
         *
         *    @method removeRow
         *    @private
         *    @param {Model} model
         */
        removeRow: function (model) {
            this._modelRowBindings[model.cid].destroy();
        },

        /**
         *    Clears all data rows in the table and empties the collection
         *
         *    @method clear
         */
        clear: function () {
            for (var i = this._rows.length - 1; i >= 0; i--) {
                this._rows[i].destroy();
            }

            for (var event in this._events) {
                this._data.removeEventHandler(event, this._events[event]);
            }
            this._data = new mvp.Collection([]);
        },

        /**
         *    Sorts the data and re-renders the rows. See <a href="../../../../jscore/latest/api/classes/ext.mvp.Collection.html#methods_sort">Collection Sort</a> for more information.
         *
         *    @method sort
         *    @param {Object} comparator
         *    @param {String} sortingMode
         */
        sort: function (comparator, sortingMode) {
            this._data.sort(comparator, sortingMode); // check for sort event from collection
        },

        /**
         *    Detaches all rows and reattached them based on the collection order
         *
         *    @method sortRender
         *    @private
         */
        sortRender: function () {
            for (var i = 0; i < this.getRows().length; i++) {
                this.getRows()[i].detach();
            }

            this._rows = [];

            this._data.each(function (model) {
                var row = this._modelRowBindings[model.cid];
                row.attach();
                this._rows.push(row);
            }.bind(this));
        },


        /**
         *    Creates and returns an array of Columns using the supplied column definitions
         *
         *    @method initializeColumns
         *    @private
         *    @param {Array<Object>} columnDefinitions
         *    @return {Array<Column>} columns
         */
        initializeColumns: function (columnDefinitions) {
            var columns = [];


            for (var i = 0; i < columnDefinitions.length; i++) {
                var column = new Column({
                    index: i,
                    definition: columnDefinitions[i]
                });

                columns.push(column);
            }

            return columns;
        },

        /**
         *    Creates and returns an array of Columns using the supplied column definitions
         *
         *    @method initializeHeaderRow
         *    @private
         *    @param {Array<Columns>} columns
         *    @return {Row} headerRow
         */
        initializeHeaderRow: function (columns) {
            var table = this;
            var headerRow = new this.headerRowType({
                eventBus: this._eventBus
            });
            var sortables = [];
            columns.forEach(function (column, i) {
                var CellType = (column.getDefinition().headerCellType || this.headerCellType);
                var cell = new CellType({
                    row: headerRow,
                    eventBus: this._eventBus,
                    column: columns[i]
                });

                if (this.options.tooltips) {
                    cell.setTooltip(columns[i].getTitle());
                }

                if (columns[i].getDefinition().sortable) {
                    var sortable = new Sortable();

                    var initialSortIcon = columns[i].getDefinition().initialSortIcon;
                    if (initialSortIcon) {
                        if (initialSortIcon == "desc") {
                            sortable.view.setDownArrowActive();
                        } else {
                            sortable.view.setUpArrowActive();
                        }
                        sortable._sortingMode = initialSortIcon;
                    }

                    var cellElement = cell.view.getBody();

                    sortable.attachTo(cellElement);
                    cellElement.addEventHandler("click", sortable.click, sortable);
                    sortable.addEventHandler('reset', function () {
                       sortables.forEach(function (current) {
                            if (this !== current) {
                                current.reset();
                            }
                        }, this);
                    }, sortable);

                    sortable.addEventHandler('sort', function (sortingMode) {
                        table.trigger("sort", this.getColumn().getAttribute(), sortingMode);
                    }, cell);

                    sortables[i] = sortable;
                }

                headerRow.attachCell(cell);
            }, this);

            return headerRow;
        },

        /**
         *    Returns the collection for the table
         *
         *    @method getData
         *    @return {Collection} data
         */
        getData: function () {
            return this._data;
        },

        /**
         *    Returns the header row for the table
         *
         *    @method getHeaderRow
         *    @return {HeaderRow} headerRow
         */
        getHeaderRow: function () {
            return this._headerRow;
        },

        /**
         *    Returns the body rows for the table
         *
         *    @method getRows
         *    @return {Array<Row>} rows
         */
        getRows: function () {
            return this._rows;
        },

        /**
         *    Returns the columns for the table
         *
         *    @method getHeaderRow
         *    @return {Array<Column>} columns
         */
        getColumns: function () {
            return this._columns;
        },

        /**
         *    Returns the event bus for the table that all components in the table can access
         *
         *    @method getEventBus
         *    @return {EventBus} eventBus
         */
        getEventBus: function () {
            return this._eventBus;
        },

        /**
         * Adds the table widget to the parent element
         *
         * @method attachTo
         * @param {Element} parent
         * @example
         *    table.attachTo(this.getElement());
         */

        /**
         * Places the detached table Widget back into the defined parent element.
         *
         * @method attach
         * @example
         *  table.attach();
         */

        /**
         * Removes the table Widget from the parent element, but does not destroy the Widget. DOM events will still work when Widget is attached back.
         *
         * @method detach
         * @example
         *  table.detach();
         */

        /**
         * Bind an event handling function to an event.
         *
         * @method addEventHandler
         * @param {String} eventName
         * @param {Function} fn
         * @return {String} id
         * @example
         * table.addEventHandler("sort", function(attribute, sortingMode) {
		 *     table.sort(attribute, sortingMode);
		 * });
         */

        /**
         * Unbind an event handling function from an event.
         *
         * @method removeEventHandler
         * @param {String} eventName
         * @param {String} id

         * @example
         *    table.removeEventHandler("sort", eventId);
         */

        /**
         * Removes the Widget root Element from the DOM.
         *
         * @method destroy
         *
         * @example
         *    table.destroy();
         */
         destroy: function () {
            for (var i = 0; i < this._rows.length; i++) {
                this._rows[i].destroy();
                this._rows[i] = undefined;
            }

            core.Widget.prototype.destroy.call(this);
            this._modelRowBindings = undefined;


        }

        /**
         * Extending the table allows you to specify options that are common amongst multiple instances of the table, preventing duplicate code. Options can override properties defined in the extended table.
         *
         * @method extend
         * @static
         * @param {Object} definition
         * @return {Table} table
         * @example
         * Table.extend({
         *     columns:[],
         *     width: "100px",
         *     selectableRows: true
         * });
         */

    });

    return Table;


});
define('widgets/Table', ['widgets/Table/Table'], function (main) { return main; });
